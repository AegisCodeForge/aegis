* webhooks

It's better to use webhooks because it's very easy to turn git hooks into a security nightmare.

Webhooks are a kind of notification mechanism. When enabled, a POST request with necessary data like commit ids and such would be sent to the pre-configured URL; the receiving end of the POST request could then move on to perform different actions.

Webhooks for repositories in Aegis are introduced with the following steps:

+ Enable webhook in repository setting.
+ Add repository-specific secret key. This key should be shared w/ the receiving end.
+ Configure URL in repository setting.

After enabling, the corresponding =update= git hook would be set with a shell script that invokes the command =aegis webhook send=.

** Verification

POST requests sent by Aegis come with an =Authentication= header of the following format:

#+begin_example
Authorization: Bearer webhook-jwt-{token}
#+end_example

...where =token= is a JWT token of the following format:

+ Header: the following:

  #+begin_src json
  {
      "alg": "HS256",
      "typ": "JWT"
  }
  #+end_src json

  ...Aegis uses HMAC SHA-256.
+ Payload: the following:

  #+begin_src json
  {
      "iss": "{timestamp}",
      "nonce": "{nonce; in integer}",
  }
  #+end_src json
+ Signature: signature signed with the pre-configured secret.

The receiving end must verify the signature with the shared pre-configured secret.

** Data structure

Data structure are similar to GitHub webhooks:

#+begin_src json
  {
  	"id": "{uuid of this webhook request}"
  	"result_report": "{result report url; see below}"
  	"result_report_id": "{result report uuid; see below}"
  	"ref": "{updated reference}",
  	"before": "{before commit id}",
  	"after": "{after commit id}",
  	"commits": [
  		{
  			"id": "{commit id}",
  			"message": "{commit message}",
  			"url": "{commit url}",
  			"author": {
  				"name": "{git commit author name}",
  				"email": "{git commit author email}",
  				"username": "{aegis user name (if exists)}",
  			},
  			"committer": {
  				"name": "{git commit author name}",
  				"email": "{git commit author email}",
  				"username": "{aegis user name (if exists)}",
  			},
  			"timestamp": "{commit time; integer}"
  		}
  	],
  	"repository": {
  		"id": "{repository absolute id; integer}",
  		"owner": {
  			"id": "{repository owner user id; integer}",
  			"login": "{repository owner user name}",
  			"full_name": "{repo owner user full name}",
  			"email": "{repo owner user email}",
  			"username": "{repo owner user name}"
  		},
  		"name": "{repository name}",
  		"namespace": "{repository namespace}",
  		"full_name": "{repository full name, slash-separated}"
  		"description": "{repository description}",
  		"fork": "{is the repo a fork; boolean}",
  		"html_url": "{repo html url}",
  		"ssh_url": "{repo ssh url}",
  		"clone_url": "{repo http clone url}",
  	}
  }
#+end_src

** Command

The following command is executed:

#+begin_example
aegis web-hooks send "$repo_full_name" "$refname" "$newrev_type" "$oldrev" "$newrev"
#+end_example

...where:

+ =$repo_full_name=: full name of the corresponding repository, colon separated.
+ =$refname=: full name of the updated ref (e.g. =refs/heads/[branch]= instead of just =[branch]=).
+ =$newrev_type= would be the type of the update:
  + =commit=: new commit.
  + =delete=: delete tag.
  + =tag=: tag.
+ =$oldrev=: the id of commit before update
+ =$newrev=: the id of commit after update

** Result report

This provides a way for the external side to report the result of the webhook. The result report endpoint currently (2025.9.20) supports JSON only. The request header should also contain the same format of JWT.

#+begin_example
Authorization: Bearer webhook-jwt-{token}
Content-Type: application/json
#+end_example

The payload part of the JWT, however, is different. The webhook request would send, alongside with other info, a special "result report id"; this should be included in the ~jti~ claim of the payload and used to generate the signature. Aegis will not accept the same result report id more than once.

#+begin_src json
  {
  	"iss": "{timestamp}",
  	"jti": "{result report id}"
  }
#+end_src

The request body should be like the following:

#+begin_src json
  {
  	"ver": 0,
  	"id": "{webhook request uuid}",
  	"status": "{status code in integer; 1 - success, 2 - failed}",
  	"message": "{accompanying message; string}"
  }
#+end_src

** Git hook template

This is a copy from Git's example =update= hook:

#+begin_src bash
  #!/bin/sh

  # --- Command line
  refname="$1"
  oldrev="$2"
  newrev="$3"

  # --- Safety check
  if [ -z "$GIT_DIR" ]; then
  	echo "Don't run this script from the command line." >&2
  	echo " (if you want, you could supply GIT_DIR then run" >&2
  	echo "  $0 <ref> <oldrev> <newrev>)" >&2
  	exit 1
  fi

  if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
  	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
  	exit 1
  fi

  # --- Config
  allowunannotated=$(git config --type=bool hooks.allowunannotated)
  allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
  denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
  allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
  allowmodifytag=$(git config --type=bool hooks.allowmodifytag)

  # --- Check types
  # if $newrev is 0000...0000, it's a commit to delete a ref.
  zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
  if [ "$newrev" = "$zero" ]; then
  	newrev_type=delete
  else
  	newrev_type=$(git cat-file -t $newrev)
  fi

  case "$refname","$newrev_type" in
  	refs/tags/*,commit)
  		# un-annotated tag
  		short_refname=${refname##refs/tags/}
  		if [ "$allowunannotated" != "true" ]; then
  			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
  			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
  			exit 1
  	    else
  			aegis web-hooks send "$repo_full_name" "$refname" "$newrev_type" "$oldrev" "$newrev"
  		fi
  		;;
  	refs/tags/*,delete)
  		# delete tag
  		if [ "$allowdeletetag" != "true" ]; then
  			echo "*** Deleting a tag is not allowed in this repository" >&2
  			exit 1
  		else
  			aegis web-hooks send "$repo_full_name" "$refname" "$newrev_type" "$oldrev" "$newrev"
  		fi
  		;;
  	refs/tags/*,tag)
  		# annotated tag
  		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
  		then
  			echo "*** Tag '$refname' already exists." >&2
  			echo "*** Modifying a tag is not allowed in this repository." >&2
  			exit 1
  		else
  			aegis web-hooks send "$repo_full_name" "$refname" "$newrev_type" "$oldrev"  "$newrev"
  		fi
  		;;
  	refs/heads/*,commit)
  		# branch
  		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
  			echo "*** Creating a branch is not allowed in this repository" >&2
  			exit 1
  		else
  			aegis web-hooks send "$repo_full_name" "$refname" "$newrev_type" "$oldrev"  "$newrev"
  		fi
  		;;
  	refs/heads/*,delete)
  		# delete branch
  		if [ "$allowdeletebranch" != "true" ]; then
  			echo "*** Deleting a branch is not allowed in this repository" >&2
  			exit 1
  		else
  			aegis web-hooks send "$repo_full_name" "$refname" "$newrev_type" "$oldrev"  "$newrev"
  		fi
  		;;
  	refs/remotes/*,commit)
  		# tracking branch
  		;;
  	refs/remotes/*,delete)
  		# delete tracking branch
  		if [ "$allowdeletebranch" != "true" ]; then
  			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
  			exit 1
  		fi
  		;;
  	,*)
  		# Anything else (is there anything else?)
  		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
  		exit 1
  		;;
  esac

  # --- Finished
  exit 0

#+end_src

