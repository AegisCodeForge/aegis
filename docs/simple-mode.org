* simple mode


this works similar to using gitolite. we don't use the proper acl in simple mode - see section about simple mode acl below.

under simple mode, two special repositories would be used for configuration:

+ ~__aegis:__keys~ (~__keys~ when ~useNamespace~ is false): repository for ssh and gpg keys.
+ ~__aegis:__repo_config~ (~__repo_config~ when ~useNamespace~ is false): repository for repo definitions and configs.

These repositories would be setup during the installation phase. If these repositories were not found when Aegis is started and is configured to run in Simple Mode, it would create the repositories accordingly. The ~__keys~ repository would be created with update hook configured, so that all updates would trigger the command ~aegis simple-mode keys-update~. The hook is written to only trigger the command when the ~master~ branch is updated.

The ~__repo_config~ repository is also created with update hook configured, so that all updates to the ~master~ branch would trigger ~aegis simple-mode config-update~. This command would go through the repository and ensure all the repositories are created. Since settings like ACL and visibilities are also done within the repository and they're


** ~__keys~

the directory structure of this repo must be as follows:

#+begin_example
+ [username1]
  + ssh
    + [user1.pubkey1.name]
    + [user1.pubkey2.name]
    + ...
  + gpg
    + [user1.gpgkey1.name]
    + [user1.gpgkey2.name}
    + ...
+ [username2]
  + ssh
    + [user2.pubkey1.name]
    + [user2.pubkey2.name]
    + ...
  + gpg
    + [user2.gpgkey1.name]
    + [user2.gpgkey2.name}
    + ...
+ ...
#+end_example

the ~update~ hook of this repo is configured to trigger command ~aegis simple-mode update-keys~, which will generate the required ~authorized_keys~ file accordingly.

** ~__repo_config~

the directory structure of this repo must be as follows:

#+begin_example
+ [namespace1]
  + config.json
  + [reponame1]
    + config.json
  + [reponame2]
    + config.json
  + ...
+ [namespace2]
  + config.json
  + [reponame1]
  + [reponame2]
  + ...
+ ...
#+end_example

if useNamespace is false, then the structure would be:

#+begin_example
  + [reponame1]
    + config.json
  + [reponame2]
    + config.json
  + ...
#+end_example

the ~.json~ that are directly under the directories for namespaces are as follows:

#+begin_src json
  {
  	"namespace": {
  		"description": "{description}",
  		"visibility": "{visibility: 'public' or 'private'}"
  	}
  }
#+end_src

  the ~.json~ files under the directories for repositories are of the following format:

#+begin_src json
  {
  	"repo": {
  		"description": "{description}",
  		"visibility": "{visibility; 'public' or 'private'.}"
  	},
  	"hooks": {
  		"{hookname1}": "{filename (resolved against location of config.json)}",
  		"{hookname2}": "{filename (resolved against location of config.json)}"
  	},
  	"users": {
  		"{username1}": {
  			"default": "{`allow` or `disallow`}",
  			// ...
  		},
  	}
  }
#+end_src

NOTE: the ~username~ part currently only has one field: ~default~. This determines whether a repo allow a particular user to push. More specific access control is planned in the future.

** simple mode acl

a simple mode acl is currently just an object composed of a ~default~ field. Reference-specific access control is currently planned for the future.

#+begin_src json
{
    "default": "allow",
}
#+end_src json

the field ~default~ must be either ~allow~ or ~disallow~. for any ref and any action that's not specified in the acl, this would be the final verdict of whether to allow the user to do things or not.

** how things are updated in simple mode

~aegis ssh~ is triggered as a separate process; this means that ~aegis ssh~ we cannot have what's in the memory of the web server process; but we need to have access control for ~aegis ssh~; this means that we have to somehow read the acl within ~aegis ssh~. we have the following two different methods:

+ directly read from ~__aegis:__repo_config~.
+ somehow have the web server process read from ~__aegis:__repo_config~ on startup, and then make ~aegis ssh~ somehow read from the web server process.

if we choose the first method, we will have to create a repository model object for ~__aegis:__repo_config~ and parse through its internal git objects every single time, which involves file IO, zlib decompress and JSON deserializing. for this reason, we currently keep a clone of this repo is thus created directly under the git folder of ~__aegis:__repo_config~ with the subfolder name ~aegis_sync~, so that we can skip the zlib decompress part (also os API is slightly easier to handle).

the update of this ~aegis_sync~ cannot be done during the execution of the ~update~ hook since the update is only complete *after* the hook has completed running. we prepare the command `aegis simple-mode aegis-sync` for this.

